<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>For contributors: Ideas and suggestions for Gambit-related projects — Gambit v0.2010.09.01 documentation</title>
    <link rel="stylesheet" href="ideas_files/default.css" type="text/css">
    <link rel="stylesheet" href="ideas_files/pygments.css" type="text/css">
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.2010.09.01',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="ideas_files/jquery.js"></script>
    <script type="text/javascript" src="ideas_files/underscore.js"></script>
    <script type="text/javascript" src="ideas_files/doctools.js"></script>
    <link rel="top" title="Gambit v0.2010.09.01 documentation" href="http://www.gambit-project.org/doc/index.html">
    <link rel="next" title="For developers: Building Gambit from source" href="http://www.gambit-project.org/doc/build.html">
    <link rel="prev" title="Sample games" href="http://www.gambit-project.org/doc/samples.html"> 
  </head>
  <body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="http://www.gambit-project.org/doc/index.html"><img src="ideas_files/gambit.png" alt="Chadwick" border="0"></a>
<font size="+3">Gambit: Software Tools for Game Theory</font>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http://www.gambit-project.org/doc/genindex.html" title="General Index" accesskey="I">index</a></li>
        <li class="right">
          <a href="http://www.gambit-project.org/doc/build.html" title="For developers: Building Gambit from source" accesskey="N">next</a> |</li>
        <li class="right">
          <a href="http://www.gambit-project.org/doc/samples.html" title="Sample games" accesskey="P">previous</a> |</li>
        <li><a href="http://www.gambit-project.org/doc/index.html">home</a>&nbsp;|&nbsp;</li>
        <li><a href="http://www.gambit-project.org/doc/search.html">search</a>&nbsp;|&nbsp;</li>
        <li><a href="http://www.gambit-project.org/doc/intro.html#section-downloading">download</a>&nbsp;|&nbsp;</li>
	<li><a href="#">project ideas</a>&nbsp;</li>
    <!--   <li><a href="contents.html">documentation </a> &raquo;</li> -->
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="http://www.gambit-project.org/doc/index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">For contributors: Ideas and suggestions for Gambit-related projects</a><ul>
<li><a class="reference internal" href="#creating-interfaces-for-game-representations">Creating interfaces for game representations</a><ul>
<li><a class="reference internal" href="#implementing-guis-for-user-friendly-input-editing-and-storage-of-game-trees">Implementing GUIs for user-friendly input, editing, and storage of game trees</a></li>
<li><a class="reference internal" href="#python-api-for-manipulating-games">Python API for manipulating games</a></li>
<li><a class="reference internal" href="#gui-for-the-input-and-manipulation-of-game-models">GUI for the input and manipulation of game models</a></li>
<li><a class="reference internal" href="#conversion-modules-between-game-representations">Conversion modules between game representations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#creating-testbeds-for-algorithms">Creating testbeds for algorithms</a><ul>
<li><a class="reference internal" href="#create-a-regression-testing-framework-for-nash-equilibrium-solvers">Create a regression-testing framework for Nash equilibrium solvers</a></li>
<li><a class="reference internal" href="#creating-interfaces-to-cloud-computing">Creating interfaces to cloud computing</a></li>
<li><a class="reference internal" href="#record-keeping-and-display-of-results-for-computational-experiments">Record-keeping and display of results for computational experiments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-algorithms-for-finding-equilibria-in-games">Implementing algorithms for finding equilibria in games</a><ul>
<li><a class="reference internal" href="#improve-integration-and-testing-of-gametracer">Improve integration and testing of Gametracer</a></li>
<li><a class="reference internal" href="#finding-all-equilibria-reachable-by-lemke-howson">Finding all equilibria reachable by Lemke-Howson</a></li>
<li><a class="reference internal" href="#finding-equilibria-reachable-by-lemke-s-algorithm-with-varying-covering-vectors">Finding equilibria reachable by Lemke’s algorithm with varying “covering vectors”</a></li>
<li><a class="reference internal" href="#computing-the-index-of-an-equilibrium-component">Computing the index of an equilibrium component</a></li>
<li><a class="reference internal" href="#enumerating-all-equilibria-of-a-two-player-game-tree">Enumerating all equilibria of a two-player game tree</a></li>
<li><a class="reference internal" href="#solving-for-equilibria-using-polynomial-systems-of-equations">Solving for equilibria using polynomial systems of equations</a></li>
<li><a class="reference internal" href="#implement-herings-peeters-homotopy-algorithm-to-compute-nash-equilibria">Implement Herings-Peeters homotopy algorithm to compute Nash equilibria</a></li>
<li><a class="reference internal" href="#representing-two-player-correlated-equilibrium-payoffs">Representing two-player correlated equilibrium payoffs</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="http://www.gambit-project.org/doc/samples.html" title="previous chapter">Sample games</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="http://www.gambit-project.org/doc/build.html" title="next chapter">For developers: Building Gambit from source</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="http://www.gambit-project.org/doc/_sources/ideas.txt" rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input name="q" size="18" type="text">
      <input value="Go" type="submit">
      <input name="check_keywords" value="yes" type="hidden">
      <input name="area" value="default" type="hidden">
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="for-contributors-ideas-and-suggestions-for-gambit-related-projects">
<h1>For contributors: Ideas and suggestions for Gambit-related projects<a class="headerlink" href="#for-contributors-ideas-and-suggestions-for-gambit-related-projects" title="Permalink to this headline">¶</a></h1>
<p>Research on doing computation on finite games, and using numerical and
algorithmic methods to analyze games, are areas of quite active
research.  There are a number of opportunities for programmers of all
skill levels and backgrounds to contribute to improving and extending
Gambit.</p>
<p>A number of such ideas are outlined in this section.  They are grouped
by the areas of focus:</p>
<ul class="simple">
<li><a class="reference internal" href="#contribute-interfaces"><em>Interfaces (graphical and API)</em></a></li>
<li><a class="reference internal" href="#contribute-testing"><em>Testing and performance comparison</em></a></li>
<li><a class="reference internal" href="#contribute-algorithms"><em>Implementation of algorithms</em></a></li>
</ul>
<p>Each project includes a recommended/preferred
implementation language, and a summary of the background prerequisites
someone should have in order to take on the project successfully, in
terms of mathematics, game theory, and software engineering.</p>
<p>The <a class="reference external" href="http://gambit.git.sourceforge.net/git/gitweb-index.cgi">Gambit source tree</a>
is managed using <a class="reference external" href="http://www.git-scm.com/">git</a>.
  It is recommended to have some familiarity with how git works, or to 
be willing to learn.  (It’s not that hard, and once you do learn it, 
you’ll wonder how you ever lived without it.)</p>
<div class="section" id="creating-interfaces-for-game-representations">
<span id="contribute-interfaces"></span><h2>Creating interfaces for game representations<a class="headerlink" href="#creating-interfaces-for-game-representations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="implementing-guis-for-user-friendly-input-editing-and-storage-of-game-trees">
<h3>Implementing GUIs for user-friendly input, editing, and storage of game trees<a class="headerlink" href="#implementing-guis-for-user-friendly-input-editing-and-storage-of-game-trees" title="Permalink to this headline">¶</a></h3>
<p>This is a core project about the manipulation of game trees
with imperfect information, also called games in extensive
form.  It should extend the existing prototype
<a class="reference external" href="http://gametheoryexplorer.appspot.com/builder/">http://gametheoryexplorer.appspot.com/builder/</a>.</p>
<ul class="simple">
<li><strong>Languages:</strong> Java and ActionScript (for Flex/Flashplayer)</li>
<li><strong>Prerequisites:</strong> Strong interest in expanding an existing code base for GUIs.
Basic game theory.</li>
</ul>
</div>
<div class="section" id="python-api-for-manipulating-games">
<h3>Python API for manipulating games<a class="headerlink" href="#python-api-for-manipulating-games" title="Permalink to this headline">¶</a></h3>
<p>Gambit’s main API for representing games is written in C++.
There is a partial, experimental interface written using
<a class="reference external" href="http://www.cython.org/">Cython</a> to allow games to be defined and manipulated using
Python.  Build out this interface to completion, and create
a test suite to exercise the interface, with special
emphasis on proper handling of error conditions.</p>
<ul class="simple">
<li><strong>Languages:</strong> C++, Python via <a class="reference external" href="http://www.cython.org/">Cython</a></li>
<li><strong>Prerequisites:</strong> Very rudimentary knowledge of game theory (which
can be picked up as one goes along); some experience with
creating Python extensions, preferably with Cython.</li>
</ul>
</div>
<div class="section" id="gui-for-the-input-and-manipulation-of-game-models">
<h3>GUI for the input and manipulation of game models<a class="headerlink" href="#gui-for-the-input-and-manipulation-of-game-models" title="Permalink to this headline">¶</a></h3>
<p>This new project applies to other models of games, for example games 
on networks such as congestion games, and Parity games and stochastic 
games on graphs.</p>
<ul class="simple">
<li><strong>Languages:</strong> Java and ActionScript (for Flex/Flashplayer),
others if experience is there</li>
<li><strong>Prerequisites:</strong> Interest in game theory or logic, senior-level computer
science or mathematics.</li>
</ul>
</div>
<div class="section" id="conversion-modules-between-game-representations">
<h3>Conversion modules between game representations<a class="headerlink" href="#conversion-modules-between-game-representations" title="Permalink to this headline">¶</a></h3>
<p>Complex game representations such as game trees have different
serialization formats in Gambit such as the
<a class="reference internal" href="http://www.gambit-project.org/doc/formats.html#file-formats"><em>.efg (extensive form game) format</em></a>
and a more recent XML format.  Utilities are to be written that convert one
format to the other in order to compare existing algorithms.  This can
be expanded from read-in methods for an internal representation of
existing algorithms.</p>
<ul class="simple">
<li><strong>Languages:</strong> Python and Java</li>
<li><strong>Prerequisites:</strong> Some game theory, junior-level or higher background in
computer science (data structures).</li>
</ul>
<p><strong>Fuller details:</strong></p>
<p>In addition to the .efg file format, there is a .xml format
used by a new interactive program for drawing extensive form
games.  The program that accesses and generates this format,
under development as part of the Gambit project, is at</p>
<p><a class="reference external" href="http://gametheoryexplorer.appspot.com/builder/">http://gametheoryexplorer.appspot.com/builder/</a></p>
<p>and a sample file reads:</p>
<div class="highlight-python"><pre>&lt;extensiveForm&gt;
  &lt;node&gt;
    &lt;node player="1" prob="9/10"&gt;
      &lt;node iset="2" player="2" move="B"&gt;
        &lt;outcome move="N"&gt;
          &lt;payoff player="1" value="3"/&gt;
          &lt;payoff player="2" value="1"/&gt;
        &lt;/outcome&gt;
        &lt;outcome move="F"&gt;
          &lt;payoff player="1" value="1"/&gt;
          &lt;payoff player="2" value="0"/&gt;
        &lt;/outcome&gt;
      &lt;/node&gt;
      &lt;node iset="4" player="2" move="Q"&gt;
        &lt;outcome move="N"&gt;
          &lt;payoff player="1" value="2"/&gt;
          &lt;payoff player="2" value="0"/&gt;
        &lt;/outcome&gt;
        &lt;outcome move="F"&gt;
          &lt;payoff player="1" value="1"/&gt;
          &lt;payoff player="2" value="0"/&gt;
        &lt;/outcome&gt;
      &lt;/node&gt;
    &lt;/node&gt;
    &lt;node player="1" prob="1/10"&gt;
      &lt;node iset="2" move="B"&gt;
        &lt;outcome move="N"&gt;
          &lt;payoff player="1" value="2"/&gt;
          &lt;payoff player="2" value="0"/&gt;
        &lt;/outcome&gt;
        &lt;outcome move="F"&gt;
          &lt;payoff player="1" value="0"/&gt;
          &lt;payoff player="2" value="1"/&gt;
        &lt;/outcome&gt;
      &lt;/node&gt;
      &lt;node iset="4" move="Q"&gt;
        &lt;outcome move="N"&gt;
          &lt;payoff player="1" value="3"/&gt;
          &lt;payoff player="2" value="1"/&gt;
        &lt;/outcome&gt;
        &lt;outcome move="F"&gt;
          &lt;payoff player="1" value="1"/&gt;
          &lt;payoff player="2" value="0"/&gt;
        &lt;/outcome&gt;
      &lt;/node&gt;
    &lt;/node&gt;
  &lt;/node&gt;
&lt;/extensiveForm&gt;</pre>
</div>
<p>which generates the game tree shown in this figure.</p>
<div class="figure align-right" style="width: 33%">
<a class="reference external image-reference" href="http://www.gambit-project.org/doc/_images/beerquiche.png"><img alt="a beer-quiche signaling game" src="ideas_files/beerquiche7.png"></a>
</div>
<p>The project is about conversion between the  .xml  and .efg
formats, and should expand the existing read-in routines
that exist in the programs for the respective formats.</p>
</div>
</div>
<div class="section" id="creating-testbeds-for-algorithms">
<span id="contribute-testing"></span><h2>Creating testbeds for algorithms<a class="headerlink" href="#creating-testbeds-for-algorithms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="create-a-regression-testing-framework-for-nash-equilibrium-solvers">
<h3>Create a regression-testing framework for Nash equilibrium solvers<a class="headerlink" href="#create-a-regression-testing-framework-for-nash-equilibrium-solvers" title="Permalink to this headline">¶</a></h3>
<p>There are a number of different methods for computing Nash
equilibria in games.  Create a framework for exercising
algorithms on a set of games, and compare the output and
performance of the methods.  Some potential complications
include rounding problems with floating-point numbers, and
that some methods only promise to return a subset of the
equilibria.  The framework should accommodate the ability
both to compare different methods, and to do regression
testing.</p>
<ul class="simple">
<li><strong>Languages:</strong> Open; Python is likely the best option</li>
<li><strong>Prerequisites:</strong> Interest in testing frameworks</li>
</ul>
</div>
<div class="section" id="creating-interfaces-to-cloud-computing">
<h3>Creating interfaces to cloud computing<a class="headerlink" href="#creating-interfaces-to-cloud-computing" title="Permalink to this headline">¶</a></h3>
<p>Algorithms with long running times can be tested fast only
with cloud computing.  Recording the computational
experiments requires scripting and output data management,
and interfacing the cloud computing environment.</p>
<ul class="simple">
<li><strong>Languages:</strong> Python</li>
<li><strong>Prerequisites:</strong> Experience with cloud computing desirable.</li>
</ul>
</div>
<div class="section" id="record-keeping-and-display-of-results-for-computational-experiments">
<h3>Record-keeping and display of results for computational experiments<a class="headerlink" href="#record-keeping-and-display-of-results-for-computational-experiments" title="Permalink to this headline">¶</a></h3>
<p>Developing a systematic way of organizing and maintaining the results
 of computational experiments in a database.  This requires book-keeping
 of programs together with their versions, and of corresponding possibly
 randomly generated data.  Creating modules for graphical and tabular 
representation of results from the database.  There may be existing 
packages of this sort around that are to be found, configured and 
adapted.</p>
<ul class="simple">
<li><strong>Languages:</strong> Python, SQL in suitable variant, possibly via
<a class="reference external" href="http://www.sqlalchemy.org/">SQLAlchemy</a>.</li>
<li><strong>Prerequisites:</strong>  Experience with scripting and data
representation desirable.</li>
</ul>
</div>
</div>
<div class="section" id="implementing-algorithms-for-finding-equilibria-in-games">
<span id="contribute-algorithms"></span><h2>Implementing algorithms for finding equilibria in games<a class="headerlink" href="#implementing-algorithms-for-finding-equilibria-in-games" title="Permalink to this headline">¶</a></h2>
<div class="section" id="improve-integration-and-testing-of-gametracer">
<h3>Improve integration and testing of Gametracer<a class="headerlink" href="#improve-integration-and-testing-of-gametracer" title="Permalink to this headline">¶</a></h3>
<p>Gambit incorporates the
<a class="reference external" href="http://dags.stanford.edu/Games/gametracer.html">Gametracer</a> package
to provide
implementations of two methods for computing equilibria,
<a class="reference internal" href="http://www.gambit-project.org/doc/tools.html#gambit-gnm"><em>gambit-gnm</em></a> and <a class="reference internal" href="http://www.gambit-project.org/doc/tools.html#gambit-ipa"><em>gambit-ipa</em></a>.
The integration
is rather crude, as internally the program converts the game
from native Gambit representation into Gametracer’s
representation, and the converts the output back.  Using
Gametracer’s implementations as a starting point, refactor
the implementation to use Gambit’s native classes directly,
and carry out experiments on the reliability and performance
of the algorithms.</p>
<ul class="simple">
<li><strong>Languages:</strong> C++</li>
<li><strong>Prerequisites:</strong> Some level of comfort with linear algebra;
enjoyment of refactoring code.</li>
</ul>
</div>
<div class="section" id="finding-all-equilibria-reachable-by-lemke-howson">
<h3>Finding all equilibria reachable by Lemke-Howson<a class="headerlink" href="#finding-all-equilibria-reachable-by-lemke-howson" title="Permalink to this headline">¶</a></h3>
<p>For a two-player in strategic form (also called bimatrix
games), what are the Nash equilibria that can be found using
the Lemke-Howson method?  Each pure strategy as an
“initially dropped label” leads to an equilibrium along a
computational path obtained by “pivoting” in a linear
system.  If two equilibria found in that way are different,
using the second label on the first equilibrium (and vice
versa) will find yet another equilibrium.  The set of all
equilibria reachable in that way should be recorded and is a
(normally) fast way to find many equilibria when the game is
large.</p>
<ul class="simple">
<li><strong>Languages:</strong> Java</li>
<li><strong>Prerequisites:</strong>
Theoretical understanding of the Lemke-Howson
method or of the Simplex algorithm for Linear Programming.
Literature exists that is accessible for students with at
least senior-level background in computer science,
mathematics or operations research.  An existing
implementation of a Lemke-Howson style pivoting algorithm
should be adapted with suitable alterations.</li>
</ul>
<p><strong>Fuller details:</strong></p>
<p>This figure shows the typical situation for a nondegenerate
two-player game:</p>
<div class="figure align-center">
<img alt="a two-player game" src="ideas_files/lh-net3.png">
</div>
<p>There is an “artificial equilibrium” 0 and five equilibria
1,2,3,4,5, each of which has a <em>sign</em> or <em>index</em> + or -.
The Lemke-Howson (LH) algorithm computes a piecewise linear
path from a known equilibrium, originally only 0, to another
equilibrium.  There are different ways to start, one for
each pure strategy of a player which define different LH
paths.  Here only two ways are shown, in blue and red.
An LH path always connects two equilibria of opposite sign,
so there are an even number of them, minus the artificial
equilibrium, which gives an odd number overall.
Here, the blue and red paths lead to two different
equilibria 1 and 2 of positive index (+).  Then the
algorithm can be run backwards on equilibrium 1 where the
blue path leads back to 0, but the red path must find
another equilibrium, here 3, of negative index (-).
The blue path from equilibrium 2 could possibly find another
negatively indexed equilibrium like 4, but does not, it also
finds 3.  So the “network” of LH paths here is not connected
and only finds equilibria 1,2,3, but not the two equilibria
4,5 which are only connected among themselves.</p>
<p>Given the LH algorithm, all this is relatively
straightforward, but there is no implementation for finding
negatively indexed equilibria and the described “network”.
It would also be useful to study if all equilibria can be
found for random or typical examples.</p>
<p>The LH algorithm is described in</p>
<blockquote>
<div><p>B. von Stengel (2007), Equilibrium computation for
two-player games in strategic and extensive form. Chapter 3,
Algorithmic Game Theory, eds. N. Nisan, T. Roughgarden, E.
Tardos, and V. Vazirani, Cambridge Univ. Press, Cambridge,
53-78.</p>
<p><a class="reference external" href="http://www.maths.lse.ac.uk/Personal/stengel/TEXTE/agt-stengel.pdf">http://www.maths.lse.ac.uk/Personal/stengel/TEXTE/agt-stengel.pdf</a></p>
</div></blockquote>
<p>It is related to the simplex algorithm for linear
programming but with a different <em>complementary</em> pivoting
rule.  It is also numerically not stable because rounding
errors may violate the rule, so it needs to be implemented
with <em>integer pivoting</em>, also described in the article.</p>
<p>There are versions around in C and Java that implement this
which are not yet part of the public Gambit code, but will
be made public once the project starts.</p>
</div>
<div class="section" id="finding-equilibria-reachable-by-lemke-s-algorithm-with-varying-covering-vectors">
<h3>Finding equilibria reachable by Lemke’s algorithm with varying “covering vectors”<a class="headerlink" href="#finding-equilibria-reachable-by-lemke-s-algorithm-with-varying-covering-vectors" title="Permalink to this headline">¶</a></h3>
<p>Related to the Lemke-Howson method above, but with a
slightly different algorithm that has an extra parameter,
called the “covering vector”.  That parameter can serve a
randomly selected starting point of the computation and
potentially reach many more equilibria.</p>
<ul class="simple">
<li><strong>Languages:</strong> Java</li>
<li><strong>Prerequisites:</strong> Theoretical understanding of the Lemke-Howson
method or of the Simplex algorithm for Linear Programming.
Literature exists that is accessible for students with at
least senior-level background in computer science,
mathematics or operations research.  An existing
implementation of a Lemke-Howson style pivoting algorithm
should be adapted with suitable alterations.</li>
</ul>
</div>
<div class="section" id="computing-the-index-of-an-equilibrium-component">
<h3>Computing the index of an equilibrium component<a class="headerlink" href="#computing-the-index-of-an-equilibrium-component" title="Permalink to this headline">¶</a></h3>
<p>The task is to implement a published algorithm to compute
the so-called index of an equilibrium component in a
bimatrix game.  This component is the output to an existing
enumeration algorithm.</p>
<ul class="simple">
<li><strong>Languages:</strong> Java and C</li>
<li><strong>Prerequisites:</strong>  Senior-level mathematics, interest in game theory
and some basic topology.</li>
</ul>
<p><strong>Fuller details:</strong></p>
<p>The aim of this project is to implement an existing
algorithm that finds the index of an equilibrium component.
The relevant description of this is chapter 2 of</p>
<blockquote>
<div><p>Anne Balthasar, Geometry and Equilibria in Bimatrix Games,
PhD Thesis, London School of Economics, 2009.</p>
<p><a class="reference external" href="http://www.maths.lse.ac.uk/Personal/stengel/phds/#anne">http://www.maths.lse.ac.uk/Personal/stengel/phds/#anne</a></p>
</div></blockquote>
<dl class="docutils">
<dt>which are pages 21-41 of</dt>
<dd><a class="reference external" href="http://www.maths.lse.ac.uk/Personal/stengel/phds/anne-final.pdf">http://www.maths.lse.ac.uk/Personal/stengel/phds/anne-final.pdf</a></dd>
</dl>
<p>The mathematics in this chapter are pretty scary (in
particular section 2.2, which is however not needed) but the
final page 41 which describes the algorithm is less scary.</p>
<p>Nevertheless, this is rather advanced material because it
builds on several different existing algorithms (for finding
extreme equilibria in bimatrix games, and “cliques” that
define convex sets of equilibria, and their non-disjoint
unions that define “components”).  It requires the
understanding of what equilibria in bimatrix games are
about.  These algorithms are described in</p>
<blockquote>
<div><p>D. Avis, G. Rosenberg, R. Savani, and B. von Stengel (2010),
Enumeration of Nash equilibria for two-player games.
Economic Theory 42, 9-37.</p>
<p><a class="reference external" href="http://www.maths.lse.ac.uk/Personal/stengel/ETissue/ARSvS.pdf">http://www.maths.lse.ac.uk/Personal/stengel/ETissue/ARSvS.pdf</a></p>
</div></blockquote>
<p>and students who do not eventually understand that text
should not work on this project.  For this reason, at least
senior-level (= third year) mathematics is required in terms of
mathematical maturity.  In the Avis et al. (2010) paper,
pages 19-21 describe the lexicographic method for pivoting
as it is used in the simplex method for linear programming.
A variant of this lexicographic method is used in the
chapter by Anne Balthasar.  Understanding this is a
requirement to work on this project (and a good test of how
accessible all this is).</p>
<p>We give here two brief examples that supplement the above
literature.  Consider the following bimatrix game.  It is
very simple, and students of game theory may find it useful
to first find out on their own what the equilibria of this
game are:</p>
<div class="highlight-python"><pre>2 x 2 Payoff matrix A:

1  1
0  1

2 x 2 Payoff matrix B:

1  1
0  1

EE = Extreme Equilibrium, EP = Expected Payoff

EE  1  P1:  (1)  1  0  EP=  1  P2:  (1)  1  0  EP=  1
EE  2  P1:  (1)  1  0  EP=  1  P2:  (2)  0  1  EP=  1
EE  3  P1:  (2)  0  1  EP=  1  P2:  (2)  0  1  EP=  1

Connected component 1:
{1, 2}  x  {2}
{1}  x  {1, 2}</pre>
</div>
<p>This shows the following:  there are 3 Nash equilibria,
which partly use the same strategies of the two players,
which are numbered (1), (2)  for each player.  It will take
a bit of time to understand the above output.  For our
purposes, the bottom “component” is most relevant:
It has two lines, and  {1, 2}  x  {2}   means
that equilibrium (1),(2)  -  which is according to the
previous list the strategy pair (1,0), (1,0)  as well as
(2),(2),   which is   (0,1), (1,0)  are “extreme
equilibria”, and moreover any convex combination of (1) and
(2) of player 1  - this is the first {1, 2} - can be
combined with strategy (2) of player 2.
This is part of the “clique” output of Algorithm 2 on page
19 of Avis et al. (2010).
There is a second such convex set of equilibria in the
second line, indicated by {1}  x  {1, 2}.
Moreover, these two convex sets intersect (in the
equilibrium  (1),(2))  and form therefore a “component” of
equilibria.  For such a component, the index has to be
found, which happens to be the integer 1 in this case.</p>
<p>The following bimatrix game has also two convex sets of Nash
equilibria, but they are disjoint and therefore listed as
separate components on their own:</p>
<div class="highlight-python"><pre>3 x 2 Payoff matrix A:

1  1
0  1
1  0

3 x 2 Payoff matrix B:

2  1
0  1
0  1

EE = Extreme Equilibrium, EP = Expected Payoff

Rational Output

EE  1  P1:  (1)    1    0    0  EP=  1  P2:  (1)  1  0  EP= 2
EE  2  P1:  (2)  1/2  1/2    0  EP=  1  P2:  (2)  0  1  EP= 1
EE  3  P1:  (3)  1/2    0  1/2  EP=  1  P2:  (1)  1  0  EP= 1
EE  4  P1:  (4)    0    1    0  EP=  1  P2:  (2)  0  1  EP= 1

Connected component 1:
{1, 3}  x  {1}

Connected component 2:
{2, 4}  x  {2}</pre>
</div>
<p>Here the first component has index 1 and the second has
index 0.  One reason for the latter is that if the game is
slightly perturbed, for example by giving a slightly lower
payoff than 1 in row 2 of the game, then the second strategy
of player 1 is strictly dominated and the equilibria (2) and
(4) of player 1, and thus the entire component 2, disappear
altogether.  This can only happen if the index is zero, so
the index gives some useful information as to whether an
equilibrium component is “robust” or “stable” when payoffs
are slightly perturbed.</p>
</div>
<div class="section" id="enumerating-all-equilibria-of-a-two-player-game-tree">
<h3>Enumerating all equilibria of a two-player game tree<a class="headerlink" href="#enumerating-all-equilibria-of-a-two-player-game-tree" title="Permalink to this headline">¶</a></h3>
<p>Extension of an existing algorithm for enumerating all
equilibria of a bimatrix game to game trees with imperfect
information using the so-called “sequence form”.  The method
is described in abstract form but not implemented.</p>
<ul class="simple">
<li><strong>Languages:</strong> Java</li>
<li><strong>Prerequisites:</strong> Background in game theory and basic linear
algebra.  Experience with Java programs of at least
medium complexity so that existing code can be expanded.</li>
</ul>
</div>
<div class="section" id="solving-for-equilibria-using-polynomial-systems-of-equations">
<h3>Solving for equilibria using polynomial systems of equations<a class="headerlink" href="#solving-for-equilibria-using-polynomial-systems-of-equations" title="Permalink to this headline">¶</a></h3>
<p>The set of Nash equilibrium conditions can be expressed as a
system of polynomial equations and inequalities.  The field
of algebraic geometry has been developing packages to
compute all solutions to a system of polynomial equations.
Two such packages are
<a class="reference external" href="http://www.math.uic.edu/%7Ejan/download.html%22">PHCpack</a> and
<a class="reference external" href="http://www.nd.edu/%7Esommese/bertini/">Bertini</a>.
Gambit has an
experimental interface, written in Python, to build the
required systems of equations, call out to the solvers, and
identify solutions corresponding to Nash equilibria.
Refactor the implementation to be more flexible and
Pythonic, and carry out experiments on the reliability and
performance of the algorithms.</p>
<ul class="simple">
<li><strong>Languages:</strong> Python</li>
<li><strong>Prerequisites:</strong> Experience with text processing to pass data to
and from the external solvers.</li>
</ul>
</div>
<div class="section" id="implement-herings-peeters-homotopy-algorithm-to-compute-nash-equilibria">
<h3>Implement Herings-Peeters homotopy algorithm to compute Nash equilibria<a class="headerlink" href="#implement-herings-peeters-homotopy-algorithm-to-compute-nash-equilibria" title="Permalink to this headline">¶</a></h3>
<p>Herings and Peeters
(<a class="reference external" href="http://dx.doi.org/10.1007/PL00004129">Economic Theory, 18(1), 159-185, 2001</a>) have proposed a
homotopy algorithm to compute Nash equilibria.  They have
created a
<a class="reference external" href="http://www.personeel.unimaas.nl/r.peeters/software.htm">first implementation of the method in Fortran</a>,
using <a class="reference external" href="http://www.netlib.org/hompack/">hompack</a>.
Create a Gambit implementation of this method, and carry out
experiments on the reliability and performance of the
algorithms.</p>
<ul class="simple">
<li><strong>Languages:</strong> C/C++, ability to at least read Fortran</li>
<li><strong>Prerequisites:</strong> Basic game theory and knowledge of pivoting
algorithms like the Simplex method for Linear Programming or
the Lemke-Howson method for games.  Senior-level
mathematics, mathematical economics, or operations research.</li>
</ul>
</div>
<div class="section" id="representing-two-player-correlated-equilibrium-payoffs">
<h3>Representing two-player correlated equilibrium payoffs<a class="headerlink" href="#representing-two-player-correlated-equilibrium-payoffs" title="Permalink to this headline">¶</a></h3>
<p>For a game, the set of correlated equilibria is a convex
polytope. For a two-player game, the set of its payoffs is
a two-dimensional polygon.  This is useful information to
draw as a first picture of which equilibrium payoffs can be expected.</p>
<ul class="simple">
<li><strong>Languages:</strong> Python, Java, or C/C++</li>
<li><strong>Prerequisites:</strong> Some knowledge of game theory and linear programming.</li>
</ul>
<p><strong>Fuller details:</strong></p>
<p>Correlated equilibrium (CE) is a generalization of Nash
equilibrium.  For a definition see
<a class="reference external" href="http://en.wikipedia.org/wiki/Correlated_equilibrium">http://en.wikipedia.org/wiki/Correlated_equilibrium</a></p>
<p>For any number of players, the set of CE is a polytope. The
“variables” of this polytope are the probabilities of a
joint distribution over strategy profiles.  Linear
inequalities that define this polytope are “incentive
constraints” that compare any two strategies of a player,
and are derived from the payoffs of the game.
Consequently, one can maximize a linear function over this
polytope by linear programming, for example any linear
combination of the players’ payoffs.</p>
<p>In a two-player game, the possible <em>payoffs</em> for the two
players in a CE define a polygon.
(For three players, they define a polytope of dimension
three, and so on.)
These payoffs give useful information about the game, for
example which Nash equilibrium payoffs - which are special
CE payoffs - can at most be expected.
What is unknown about the polygon are its <em>vertices</em>.
The following picture shows a polygon with 7 vertices
numbered 1,2,...,7.</p>
<div class="figure align-center">
<img alt="polygon with vertices" src="ideas_files/corr-direc.png">
</div>
<p>In this figure, if the horizontal direction is the payoff to
player 1 and the vertical direction is the payoff to player 2,
then vertices 5 and 1 are the CE with maximum (minimum)
payoff to player 1, vertices 2 and 3 give maximum payoff to
player 2, and vertex 6 gives minimum payoff to player 2.</p>
<p>How can one identify the vertices when the only access to
the polygon is via maximizing linear functions of the two
coordinates?  By trying out different directions
intelligently.  Maximizing in direction x gives vertex 2,
maximizing in direction y gives vertex 3.  If the linear
function z that is orthogonal to the line that connects 2
and 3 is maximized at both 2 and 3, then there is no further
vertex between them.  For comparison, suppose direction w is
maximized at 5.  Then the line that connects 3 and 5 gives
a direction (not shown) that is <em>not</em> maximized at both 3
and 5, but instead yields another vertex 4.  This should
give a quick picture of the possible CE payoffs.
(Extending this to 3 players is a whole new challenge, and
would require interfacing with 3D-drawing programs, if this
is worth pursuing.)</p>
<p>The possible CE payoffs can be used as bounds in the search
for Nash equilibria in enumeration programs such as those
described in</p>
<blockquote>
<div><p>D. Avis, G. Rosenberg, R. Savani, and B. von Stengel (2010),
Enumeration of Nash equilibria for two-player games.
Economic Theory 42, 9-37.</p>
<p><a class="reference external" href="http://www.maths.lse.ac.uk/Personal/stengel/ETissue/ARSvS.pdf">http://www.maths.lse.ac.uk/Personal/stengel/ETissue/ARSvS.pdf</a></p>
</div></blockquote>
<p>which may be a useful interface (that would have to be
tested for its usefulness) to equilibrium enumeration.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="http://www.gambit-project.org/doc/genindex.html" title="General Index">index</a></li>
        <li class="right">
          <a href="http://www.gambit-project.org/doc/build.html" title="For developers: Building Gambit from source">next</a> |</li>
        <li class="right">
          <a href="http://www.gambit-project.org/doc/samples.html" title="Sample games">previous</a> |</li>
        <li><a href="http://www.gambit-project.org/doc/index.html">home</a>&nbsp;|&nbsp;</li>
        <li><a href="http://www.gambit-project.org/doc/search.html">search</a>&nbsp;|&nbsp;</li>
        <li><a href="http://www.gambit-project.org/doc/intro.html#section-downloading">download</a>&nbsp;|&nbsp;</li>
	<li><a href="#">project ideas</a>&nbsp;</li>
    <!--   <li><a href="contents.html">documentation </a> &raquo;</li> -->
 
      </ul>
    </div>
    <div class="footer">
        © Copyright 2010, The Gambit Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  
</body></html>